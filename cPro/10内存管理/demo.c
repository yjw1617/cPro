// c/c++有四个内存存储区
// 代码区,全局变量与静态变量区，局部变量区即战区，堆区
#include <stdio.h>
// 1.6、栈的理解：（1） 运行时自动分配&自动回收：栈是自动管理的，程序员不需要手工干预。方便简单。（表现在汇编代码，编译时，会自动编译成汇编码实现函数调用完立即改变栈顶）
// （2） 反复使用：栈内存在程序中其实就是那一块空间，程序反复使用这一块空间。(硬件上有个寄存器，用来存放栈的栈顶地址，栈是有大小的空间)
// （3） 脏内存：栈内存由于反复使用，每次使用后程序不会去清理，因此分配到时保留原来的值。
// （4） 临时性：（函数不能返回栈变量的指针，因为这个空间是临时的）
// （5） 栈会溢出：因为操作系统事先给定了栈的大小，如果在函数中无穷尽的分配栈内存总能用完。栈的操作（怎么出栈怎么入栈）是由具体硬件来干预，程序员只要明白原理就可以了，但是要给相应的栈寄存器赋值。当调用函数时，变量会自动放在栈中（入栈）当函数调用完后，栈会自动出栈.
// ( 6 ) 栈的 "发展"有四种情况，满增栈，满减栈，空增栈，空减栈，至于是那种要根据编译器决定，而s5pv21 是满减栈


// 1.7、堆的理解：（1）操作系统堆管理器管理：堆管理器是操作系统的一个模块，堆管理内存分配灵活，按需分配。
// （2）大块内存：堆内存管理者总量很大的操作系统内存块，各进程可以按需申请使用，使用完释放。
// （3）脏内存：堆内存也是反复使用的，而且使用者用完释放前不会清除，因此也是脏的。
// （4）临时性：堆内存只在malloc和free之间属于我这个进程，而可以访问。在malloc之前和free之后都不能再访问，否则会有不可预料的后果。
// （5）程序手动申请&释放：手工意思是需要写代码去申请malloc和释放free。（记住：不要把申请的地址给搞丢了， 不然自己用不了，也释放不了）
// 临时性：栈（函数不能返回栈变量的指针，因为这个空间是临时的）
// 脏内存：栈和堆内存也是反复使用的，而且使用者用完释放前不会清除，因此也是脏的。
int main(int argc, char** argv){
    
    return 0;
}